/* automatically generated by rust-bindgen 0.60.1 */

pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type size_t = ::std::os::raw::c_ulonglong;
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LCKernel {
    pub __: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__LCKernel() {
    assert_eq!(
        ::std::mem::size_of::<_LCKernel>(),
        8usize,
        concat!("Size of: ", stringify!(_LCKernel))
    );
    assert_eq!(
        ::std::mem::align_of::<_LCKernel>(),
        1usize,
        concat!("Alignment of ", stringify!(_LCKernel))
    );
    fn test_field__() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LCKernel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LCKernel),
                "::",
                stringify!(__)
            )
        );
    }
    test_field__();
}
pub type LCKernel = *mut _LCKernel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LCFunction {
    pub __: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__LCFunction() {
    assert_eq!(
        ::std::mem::size_of::<_LCFunction>(),
        8usize,
        concat!("Size of: ", stringify!(_LCFunction))
    );
    assert_eq!(
        ::std::mem::align_of::<_LCFunction>(),
        1usize,
        concat!("Alignment of ", stringify!(_LCFunction))
    );
    fn test_field__() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LCFunction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LCFunction),
                "::",
                stringify!(__)
            )
        );
    }
    test_field__();
}
pub type LCFunction = *mut _LCFunction;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LCCallable {
    pub __: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__LCCallable() {
    assert_eq!(
        ::std::mem::size_of::<_LCCallable>(),
        8usize,
        concat!("Size of: ", stringify!(_LCCallable))
    );
    assert_eq!(
        ::std::mem::align_of::<_LCCallable>(),
        1usize,
        concat!("Alignment of ", stringify!(_LCCallable))
    );
    fn test_field__() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LCCallable>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LCCallable),
                "::",
                stringify!(__)
            )
        );
    }
    test_field__();
}
pub type LCCallable = *mut _LCCallable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LCType {
    pub __: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__LCType() {
    assert_eq!(
        ::std::mem::size_of::<_LCType>(),
        8usize,
        concat!("Size of: ", stringify!(_LCType))
    );
    assert_eq!(
        ::std::mem::align_of::<_LCType>(),
        1usize,
        concat!("Alignment of ", stringify!(_LCType))
    );
    fn test_field__() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LCType>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LCType),
                "::",
                stringify!(__)
            )
        );
    }
    test_field__();
}
pub type LCType = *mut _LCType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LCExpression {
    pub __: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__LCExpression() {
    assert_eq!(
        ::std::mem::size_of::<_LCExpression>(),
        8usize,
        concat!("Size of: ", stringify!(_LCExpression))
    );
    assert_eq!(
        ::std::mem::align_of::<_LCExpression>(),
        1usize,
        concat!("Alignment of ", stringify!(_LCExpression))
    );
    fn test_field__() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LCExpression>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LCExpression),
                "::",
                stringify!(__)
            )
        );
    }
    test_field__();
}
pub type LCExpression = *mut _LCExpression;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LCConstantData {
    pub __: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__LCConstantData() {
    assert_eq!(
        ::std::mem::size_of::<_LCConstantData>(),
        8usize,
        concat!("Size of: ", stringify!(_LCConstantData))
    );
    assert_eq!(
        ::std::mem::align_of::<_LCConstantData>(),
        1usize,
        concat!("Alignment of ", stringify!(_LCConstantData))
    );
    fn test_field__() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LCConstantData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LCConstantData),
                "::",
                stringify!(__)
            )
        );
    }
    test_field__();
}
pub type LCConstantData = *mut _LCConstantData;
extern "C" {
    pub fn luisa_compute_ast_begin_kernel() -> LCKernel;
}
extern "C" {
    pub fn luisa_compute_ast_end_kernel(arg1: LCKernel);
}
extern "C" {
    pub fn luisa_compute_ast_begin_callable() -> LCCallable;
}
extern "C" {
    pub fn luisa_compute_ast_end_callable(arg1: LCCallable);
}
extern "C" {
    pub fn luisa_compute_ast_destroy_function(arg1: LCFunction);
}
extern "C" {
    pub fn luisa_compute_ast_create_constant_data(
        t: LCType,
        data: *mut ::std::os::raw::c_void,
        n: size_t,
    ) -> LCConstantData;
}
extern "C" {
    pub fn luisa_compute_ast_destroy_constant_data(data: LCConstantData);
}
extern "C" {
    pub fn luisa_compute_ast_set_block_size(sx: u32, sy: u32, sz: u32);
}
extern "C" {
    pub fn luisa_compute_ast_thread_id() -> LCExpression;
}
extern "C" {
    pub fn luisa_compute_ast_block_id() -> LCExpression;
}
extern "C" {
    pub fn luisa_compute_ast_dispatch_id() -> LCExpression;
}
extern "C" {
    pub fn luisa_compute_ast_dispatch_size() -> LCExpression;
}
extern "C" {
    pub fn luisa_compute_type_from_description(arg1: *const ::std::os::raw::c_char) -> LCType;
}
extern "C" {
    pub fn luisa_compute_ast_local_variable(t: LCType) -> LCExpression;
}
extern "C" {
    pub fn luisa_compute_ast_shared_variable(t: LCType) -> LCExpression;
}
extern "C" {
    pub fn luisa_compute_ast_constant_variable(
        t: LCType,
        data: *const ::std::os::raw::c_void,
    ) -> LCExpression;
}
extern "C" {
    pub fn luisa_compute_ast_buffer_binding(
        elem_t: LCType,
        buffer: u64,
        offset_bytes: size_t,
        size_bytes: size_t,
    ) -> LCExpression;
}
extern "C" {
    pub fn luisa_compute_ast_texture_binding(t: LCType, texture: u64, level: u32) -> LCExpression;
}
extern "C" {
    pub fn luisa_compute_ast_bindless_array_binding(array: u64) -> LCExpression;
}
extern "C" {
    pub fn luisa_compute_ast_accel_binding(accel: u64) -> LCExpression;
}
extern "C" {
    pub fn luisa_compute_ast_value_argument(t: LCType) -> LCExpression;
}
extern "C" {
    pub fn luisa_compute_ast_reference_argument(t: LCType) -> LCExpression;
}
extern "C" {
    pub fn luisa_compute_ast_buffer_argument(t: LCType) -> LCExpression;
}
extern "C" {
    pub fn luisa_compute_ast_texture_argument(t: LCType) -> LCExpression;
}
extern "C" {
    pub fn luisa_compute_ast_bindless_array_argument() -> LCExpression;
}
extern "C" {
    pub fn luisa_compute_ast_accel_argument() -> LCExpression;
}
extern "C" {
    pub fn luisa_compute_ast_literal_expr(
        t: LCType,
        value: *const ::std::os::raw::c_void,
        meta_value: *const ::std::os::raw::c_char,
    ) -> LCExpression;
}
extern "C" {
    pub fn luisa_compute_ast_unary_expr(t: LCType, op: u32, expr: LCExpression) -> LCExpression;
}
extern "C" {
    pub fn luisa_compute_ast_binary_expr(
        t: LCType,
        op: u32,
        lhs: LCExpression,
        rhs: LCExpression,
    ) -> LCExpression;
}
extern "C" {
    pub fn luisa_compute_ast_member_expr(
        t: LCType,
        self_: LCExpression,
        member_id: size_t,
    ) -> LCExpression;
}
extern "C" {
    pub fn luisa_compute_ast_swizzle_expr(
        t: LCType,
        self_: LCExpression,
        swizzle_size: size_t,
        swizzle_code: u64,
    ) -> LCExpression;
}
extern "C" {
    pub fn luisa_compute_ast_access_expr(
        t: LCType,
        range: LCExpression,
        index: LCExpression,
    ) -> LCExpression;
}
extern "C" {
    pub fn luisa_compute_ast_cast_expr(t: LCType, op: u32, expr: LCExpression) -> LCExpression;
}
extern "C" {
    pub fn luisa_compute_ast_call_expr(
        t: LCType,
        call_op: u32,
        custom_callable: LCCallable,
        args: *const LCExpression,
        arg_count: size_t,
    ) -> LCExpression;
}
